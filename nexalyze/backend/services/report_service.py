import os
import asyncio
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime, timedelta
import logging
from io import BytesIO
import json
import base64
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.patches import Rectangle
import plotly.graph_objects as go
import plotly.express as px
from plotly.offline import plot
import plotly.io as pio

# Report generation libraries
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.lib import colors
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT, TA_JUSTIFY
from reportlab.graphics.shapes import Drawing
from reportlab.graphics.charts.piecharts import Pie
from reportlab.graphics.charts.barcharts import VerticalBarChart
from reportlab.graphics.charts.linecharts import HorizontalLineChart

# For DOCX generation
try:
    from docx import Document
    from docx.shared import Inches, Pt
    from docx.enum.text import WD_ALIGN_PARAGRAPH
    from docx.oxml.shared import OxmlElement, qn
    DOCX_AVAILABLE = True
except ImportError:
    DOCX_AVAILABLE = False

# Web scraping and analysis
import requests
from bs4 import BeautifulSoup
import yfinance as yf
from textblob import TextBlob
import re

from services.data_service import DataService
from services.research_service import ResearchService

logger = logging.getLogger(__name__)

# Set plotting style
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

class ReportService:
    def __init__(self):
        self.data_service = DataService()
        self.research_service = ResearchService()
        self.reports_dir = "reports"
        self.charts_dir = "charts"
        
        # Create directories if they don't exist
        for directory in [self.reports_dir, self.charts_dir]:
            if not os.path.exists(directory):
                os.makedirs(directory)
        
        # Configure plotting
        plt.rcParams['figure.figsize'] = (10, 6)
        plt.rcParams['figure.dpi'] = 300
        plt.rcParams['savefig.dpi'] = 300
        plt.rcParams['savefig.bbox'] = 'tight'
    
    async def generate_comprehensive_report(self, topic: str, report_type: str = "comprehensive", format: str = "pdf", use_langgraph: bool = True) -> Dict[str, Any]:
        """
        Generate a comprehensive report using LangGraph agent workflow.
        
        The LangGraph agent follows this workflow:
        1. Content Table Agent: Creates structured content table with sections
        2. Section Generation: Generates each section with data-driven insights
        3. Report Compilation: Compiles sections into final PDF/DOCX report
        """
        try:
            logger.info(f"Generating {report_type} report for topic '{topic}' in {format} format (LangGraph: {use_langgraph})")
            
            if use_langgraph:
                # Use LangGraph report agent
                from agents.report_agent import get_report_agent_graph
                from langchain_core.messages import HumanMessage
                from datetime import datetime as dt
                
                graph = get_report_agent_graph()
                session_id = f"report_{dt.now().timestamp()}"
                
                # Get initial data for context
                companies = await self.data_service.search_companies(topic, 20)
                
                initial_state = {
                    "messages": [HumanMessage(content=f"Generate a {report_type} report on {topic}")],
                    "session_id": session_id,
                    "topic": topic,
                    "report_type": report_type,
                    "content_table": None,
                    "current_section": None,
                    "report_sections": [],
                    "status": "drafting"
                }
                
                config = {
                    "configurable": {
                        "thread_id": session_id
                    }
                }
                
                logger.info(f"Invoking LangGraph report agent for topic: {topic}")
                result = await graph.ainvoke(initial_state, config=config)
                
                # Extract generated sections
                report_sections = result.get("report_sections", [])
                content_table = result.get("content_table")
                
                if not report_sections:
                    logger.warning("No sections generated by LangGraph agent, falling back to traditional method")
                    return await self._generate_traditional_report(topic, report_type, format)
                
                # Generate charts using traditional method (still useful)
                analysis_data = await self._analyze_topic_comprehensively(topic, report_type)
                chart_paths = await self._generate_charts_for_topic(topic, analysis_data)
                
                # Compile report from LangGraph sections
                if format.lower() == "pdf":
                    report_path = await self._compile_langgraph_report_to_pdf(
                        topic, report_sections, content_table, analysis_data, chart_paths, report_type
                    )
                elif format.lower() == "docx" and DOCX_AVAILABLE:
                    report_path = await self._compile_langgraph_report_to_docx(
                        topic, report_sections, content_table, analysis_data, chart_paths, report_type
                    )
                else:
                    raise ValueError(f"Unsupported format: {format}")
                
                return {
                    "success": True,
                    "report_path": report_path,
                    "report_filename": os.path.basename(report_path),
                    "topic": topic,
                    "report_type": report_type,
                    "format": format,
                    "charts_generated": len(chart_paths),
                    "sections_generated": len(report_sections),
                    "generated_at": datetime.now().isoformat(),
                    "method": "langgraph"
                }
            else:
                # Fallback to traditional method
                return await self._generate_traditional_report(topic, report_type, format)
            
        except Exception as e:
            logger.error(f"Report generation failed for topic '{topic}': {e}")
            import traceback
            traceback.print_exc()
            # Try fallback
            try:
                logger.info("Attempting fallback to traditional report generation")
                return await self._generate_traditional_report(topic, report_type, format)
            except Exception as fallback_error:
                logger.error(f"Fallback also failed: {fallback_error}")
                return {
                    "success": False,
                    "error": str(e)
                }
    
    async def _generate_traditional_report(self, topic: str, report_type: str, format: str) -> Dict[str, Any]:
        """Fallback traditional report generation method"""
        logger.info(f"Using traditional report generation for {topic}")
        
        # Analyze the topic comprehensively with report type
        analysis_data = await self._analyze_topic_comprehensively(topic, report_type)
        
        # Generate charts and visualizations
        chart_paths = await self._generate_charts_for_topic(topic, analysis_data)
        
        # Generate report based on format
        if format.lower() == "pdf":
            report_path = await self._generate_enhanced_pdf_report(topic, analysis_data, chart_paths, report_type)
        elif format.lower() == "docx" and DOCX_AVAILABLE:
            report_path = await self._generate_enhanced_docx_report(topic, analysis_data, chart_paths, report_type)
        else:
            raise ValueError(f"Unsupported format: {format}")
        
        return {
            "success": True,
            "report_path": report_path,
            "report_filename": os.path.basename(report_path),
            "topic": topic,
            "report_type": report_type,
            "format": format,
            "charts_generated": len(chart_paths),
            "generated_at": datetime.now().isoformat(),
            "method": "traditional"
        }
    
    async def _analyze_topic_comprehensively(self, topic: str, report_type: str = "comprehensive") -> Dict[str, Any]:
        """Perform comprehensive analysis of any topic"""
        try:
            analysis = {
                'topic': topic,
                'report_type': report_type,
                'analysis_date': datetime.now().isoformat(),
                'executive_summary': {},
                'market_analysis': {},
                'company_analysis': {},
                'technology_analysis': {},
                'competitive_landscape': {},
                'trend_analysis': {},
                'financial_analysis': {},
                'risk_assessment': {},
                'opportunities': {},
                'recommendations': {},
                'data_sources': []
            }
            
            # Get companies related to the topic
            companies = await self.data_service.search_companies(topic, 20)
            analysis['companies'] = companies
            
            # Executive Summary - use report_type specific prompt
            analysis['executive_summary'] = await self._generate_executive_summary(topic, companies, report_type)
            
            # Market Analysis
            analysis['market_analysis'] = await self._analyze_market(topic, companies)
            
            # Company Analysis
            analysis['company_analysis'] = await self._analyze_companies(companies)
            
            # Technology Analysis
            # analysis['technology_analysis'] = await self._analyze_technology(topic)
            
            # Competitive Landscape
            analysis['competitive_landscape'] = await self._analyze_competitive_landscape(topic, companies)
            
            # Trend Analysis
            # analysis['trend_analysis'] = await self._analyze_trends(topic)
            
            # Financial Analysis
            analysis['financial_analysis'] = await self._analyze_financials(topic, companies)
            
            # Risk Assessment
            # analysis['risk_assessment'] = await self._assess_risks(topic, companies)
            
            # Opportunities
            # analysis['opportunities'] = await self._identify_opportunities(topic, companies)
            
            # Recommendations
            # analysis['recommendations'] = await self._generate_recommendations(topic, analysis)
            
            return analysis
            
        except Exception as e:
            logger.error(f"Comprehensive analysis failed for topic '{topic}': {e}")
            raise
    
    def _get_report_prompt_by_type(self, report_type: str, topic: str, companies: List[Dict]) -> str:
        """Get detailed, tailored prompt for each report type"""
        company_names = [c.get('name', 'Unknown') for c in companies[:10]]
        industries = list(set(c.get('industry', 'Unknown') for c in companies))
        locations = list(set(c.get('location', 'Unknown') for c in companies))
        
        prompts = {
            "comprehensive": f"""Generate a COMPREHENSIVE market intelligence report for {topic}:

DATA CONTEXT:
- Total companies analyzed: {len(companies)}
- Key players: {', '.join(company_names)}
- Industry sectors: {', '.join(industries[:5])}
- Geographic reach: {', '.join(locations[:5])}

REQUIRED SECTIONS (Be extremely detailed):

1. EXECUTIVE SUMMARY (250-300 words)
   - Market overview and current state
   - Total Addressable Market (TAM) estimate with methodology
   - Key trends driving growth
   - Critical success factors

2. MARKET ANALYSIS
   - Market size ($B) and growth rate (% CAGR)
   - Market segmentation by industry, geography, stage
   - Competitive landscape intensity (Porter's 5 Forces)
   - Entry barriers and regulatory environment

3. COMPANY ECOSYSTEM
   - Top 5 market leaders and their strategies
   - Emerging players to watch
   - M&A activity and consolidation trends
   - Innovation hotspots

4. TECHNOLOGY TRENDS
   - Core technologies and platforms
   - Innovation areas and R&D focus
   - Technology adoption curves
   - Future technology roadmap

5. INVESTMENT LANDSCAPE
   - Total funding raised across ecosystem
   - Average funding by stage
   - Top investors and their theses
   - Valuation trends and metrics

6. STRATEGIC RECOMMENDATIONS
   - Opportunities for new entrants
   - Partnership opportunities
   - Risk mitigation strategies
   - 3-5 year outlook

Be data-driven, cite specific numbers, and provide actionable insights.""",
            
            "executive": f"""Create an EXECUTIVE SUMMARY report for {topic} (optimized for C-suite):

DATA:
- Companies: {len(companies)}
- Leaders: {', '.join(company_names[:5])}
- Sectors: {', '.join(industries[:3])}

FOCUS ON:
1. THE BIG PICTURE (100 words)
   - Market size in $B
   - Growth trajectory
   - Why this matters now

2. KEY FINDINGS (3-5 bullet points)
   - Most important insights
   - Game-changing trends
   - Critical decisions needed

3. OPPORTUNITIES & RISKS
   - Top 3 opportunities with ROI potential
   - Top 3 risks with mitigation strategies

4. RECOMMENDED ACTIONS
   - Immediate actions (30 days)
   - Medium-term strategy (90 days)
   - Long-term positioning (1 year)

Make it concise, impactful, and decision-focused. Use simple language, avoid jargon.""",
            
            "detailed": f"""Produce a DETAILED ANALYTICAL REPORT for {topic}:

DATASET:
- {len(companies)} companies analyzed
- Primary: {', '.join(company_names[:8])}
- Industries: {', '.join(industries)}
- Locations: {', '.join(locations)}

DEEP DIVE REQUIREMENTS:

1. MARKET DYNAMICS (500+ words)
   - Supply and demand analysis
   - Pricing models and economics
   - Customer segments and personas
   - Distribution channels and partnerships

2. COMPETITIVE INTELLIGENCE
   - Detailed SWOT for top 5 companies
   - Competitive positioning matrix
   - Market share estimates
   - Differentiation strategies

3. FINANCIAL ANALYSIS
   - Revenue models and monetization
   - Unit economics and burn rates
   - Funding patterns by stage
   - Path to profitability analysis

4. OPERATIONAL INSIGHTS
   - Team sizes and composition
   - Technology stacks
   - Go-to-market strategies
   - Customer acquisition approaches

5. RISK ASSESSMENT
   - Market risks (demand, competition)
   - Technology risks (obsolescence)
   - Regulatory risks (compliance)
   - Financial risks (funding winter)

6. SCENARIO PLANNING
   - Best case: Market boom scenario
   - Base case: Steady growth scenario
   - Worst case: Market contraction scenario

Include specific examples, case studies, and quantitative data throughout.""",
            
            "market_overview": f"""Generate a MARKET OVERVIEW report for {topic}:

CONTEXT:
- Market participants: {len(companies)}
- Sample: {', '.join(company_names[:6])}
- Industries: {', '.join(industries[:4])}

STRUCTURE:

1. MARKET SNAPSHOT
   - Current market size ($B)
   - 5-year growth forecast (CAGR %)
   - Key market segments
   - Geographic breakdown

2. MARKET STRUCTURE
   - Concentration (HHI index)
   - Top 5 players market share %
   - Market fragmentation level
   - Entry/exit dynamics

3. VALUE CHAIN ANALYSIS
   - Upstream (suppliers, partners)
   - Core (main players)
   - Downstream (customers, channels)
   - Key value drivers

4. MARKET FORCES
   - Growth drivers (top 5)
   - Headwinds and challenges
   - Regulatory landscape
   - Economic indicators

5. FUTURE OUTLOOK
   - 1-year forecast
   - 3-year projections
   - Disruptive factors
   - Strategic implications

Focus on market-level insights, not individual companies.""",
            
            "competitive_analysis": f"""Create a COMPETITIVE ANALYSIS report for {topic}:

COMPETITORS ANALYZED:
- {len(companies)} companies
- Focus on: {', '.join(company_names[:7])}

COMPETITIVE INTELLIGENCE:

1. MARKET POSITIONING
   - Leader, Challenger, Niche, Follower classification
   - Positioning matrix (price vs features)
   - Brand strength assessment
   - Customer perception

2. COMPETITIVE ADVANTAGES
   For each top 5 competitor:
   - Core competencies
   - Unique value propositions
   - Barriers to entry they've built
   - Moat strength (1-10 scale)

3. STRATEGIC MOVES
   - Recent M&A activity
   - Product launches and innovation
   - Partnerships and alliances
   - Geographic expansion

4. PERFORMANCE METRICS
   - Growth rates (revenue, users, market share)
   - Profitability indicators
   - Efficiency ratios
   - Customer satisfaction scores

5. COMPETITIVE THREATS
   - Direct competitors
   - Indirect competitors
   - New entrants risk
   - Substitute products/services

6. STRATEGIC GAPS
   - Underserved market segments
   - White space opportunities
   - Weak competitive areas
   - Innovation opportunities

Provide a competitive matrix table with scores across 10+ dimensions."""
        }
        
        # Return the appropriate prompt or comprehensive as default
        return prompts.get(report_type, prompts["comprehensive"])
    
    async def _generate_executive_summary(self, topic: str, companies: List[Dict], report_type: str = "comprehensive") -> Dict[str, Any]:
        """Generate AI-powered executive summary using LLM with report-type specific prompts"""
        try:
            # Prepare context data
            industries = list(set(c.get('industry', 'Unknown') for c in companies))
            locations = list(set(c.get('location', 'Unknown') for c in companies))
            
            # Use detailed prompt based on report type
            prompt = self._get_report_prompt_by_type(report_type, topic, companies)

            # Use Bedrock via ResearchService
            if self.research_service.llm_service:
                llm_response = await self.research_service.llm_service.generate_text(prompt, temperature=0.7)
            else:
                llm_response = "AI service unavailable for summary generation."
            
            # Parse LLM response and structure it
            return {
                'overview': llm_response if isinstance(llm_response, str) else f"Analysis of {topic} sector with {len(companies)} companies.",
                'key_findings': [
                    f"Market presence: {len(companies)} active companies across {len(industries)} industries",
                    f"Geographic distribution: {len(locations)} locations with global reach",
                    f"Industry concentration: Top segments include {', '.join(industries[:3])}",
                    f"Innovation indicators: Strong activity in {', '.join([c.get('yc_batch', 'recent cohorts') for c in companies[:3]])}"
                ],
                'market_size_estimate': f"${len(companies) * 15}M - ${len(companies) * 75}M TAM",
                'growth_rate': f"{8 + (len(companies) // 10)}% CAGR (estimated)",
                'key_metrics': {
                    'total_companies_analyzed': len(companies),
                    'market_segments': len(industries),
                    'geographic_coverage': len(locations),
                    'data_quality': 'High - Real YC company data'
                },
                'ai_insights': llm_response if isinstance(llm_response, str) else "AI analysis completed"
            }
        except Exception as e:
            logger.error(f"LLM summary generation failed, using fallback: {e}")
            # Fallback to basic summary
            return {
                'overview': f"Comprehensive analysis of {topic} market with {len(companies)} companies",
                'key_findings': [
                    f"Active companies: {len(companies)}",
                    f"Market segments: {len(set(c.get('industry', '') for c in companies))}",
                    f"Geographic spread: {len(set(c.get('location', '') for c in companies))} locations"
                ],
                'market_size_estimate': f"${len(companies) * 20}M estimated",
                'growth_rate': "Strong growth trajectory",
                'key_metrics': {
                    'total_companies_analyzed': len(companies),
                    'data_quality': 'Real YC data'
                }
            }
    
    async def _analyze_market(self, topic: str, companies: List[Dict]) -> Dict[str, Any]:
        """Analyze market dynamics"""
        industries = {}
        locations = {}
        founding_years = {}
        stages = {}
        
        for company in companies:
            # Industry distribution
            industry = company.get('industry', 'Unknown')
            industries[industry] = industries.get(industry, 0) + 1
            
            # Geographic distribution
            location = company.get('location', 'Unknown')
            locations[location] = locations.get(location, 0) + 1
            
            # Founding year trends
            year = company.get('founded_year', 2020)
            if year:
                year_range = f"{(year//5)*5}s"
                founding_years[year_range] = founding_years.get(year_range, 0) + 1
            
            # Stage distribution
            stage = company.get('stage', 'Unknown')
            stages[stage] = stages.get(stage, 0) + 1
        
        return {
            'market_size': {
                'companies_analyzed': len(companies),
                'estimated_tam': f"${len(companies) * 25}B",
                'addressable_market': f"${len(companies) * 5}B"
            },
            'industry_distribution': industries,
            'geographic_distribution': locations,
            'temporal_distribution': founding_years,
            'maturity_distribution': stages,
            'market_dynamics': {
                'growth_drivers': [
                    f"Increasing adoption of {topic} technologies",
                    "Digital transformation initiatives",
                    "Regulatory support and favorable policies",
                    "Rising consumer demand"
                ],
                'market_barriers': [
                    "High capital requirements",
                    "Regulatory compliance costs",
                    "Technical complexity",
                    "Market competition intensity"
                ]
            },
            'market_trends': {
                'emerging_segments': list(industries.keys())[:3],
                'declining_segments': ["Legacy systems", "Traditional approaches"],
                'growth_segments': list(industries.keys())[:5]
            }
        }
    
    async def _analyze_companies(self, companies: List[Dict]) -> Dict[str, Any]:
        """Analyze companies in detail"""
        if not companies:
            return {'message': 'No companies found for analysis'}
        
        # Top companies by various metrics
        top_companies = {
            'by_funding': sorted([c for c in companies if c.get('funding')], 
                                key=lambda x: self._parse_funding(x.get('funding', '0')), reverse=True)[:5],
            'by_employees': sorted([c for c in companies if c.get('employees')], 
                                 key=lambda x: self._parse_employees(x.get('employees', '0')), reverse=True)[:5],
            'by_age': sorted([c for c in companies if c.get('founded_year')], 
                           key=lambda x: x.get('founded_year', 2023), reverse=True)[:5]
        }
        
        # Company performance metrics
        performance_metrics = {
            'average_age': np.mean([2024 - c.get('founded_year', 2020) for c in companies if c.get('founded_year')]),
            'total_funding': sum([self._parse_funding(c.get('funding', '0')) for c in companies]),
            'average_funding': np.mean([self._parse_funding(c.get('funding', '0')) for c in companies if c.get('funding')]),
            'success_rate': len([c for c in companies if c.get('stage') in ['Public', 'Acquired']]) / len(companies) * 100
        }
        
        return {
            'top_companies': top_companies,
            'performance_metrics': performance_metrics,
            'company_profiles': companies[:10],  # Detailed profiles of top 10
            'success_stories': [c for c in companies if c.get('stage') in ['Public', 'Acquired', 'Series C', 'Series D']],
            'emerging_players': [c for c in companies if c.get('stage') in ['Seed', 'Series A', 'Series B']]
        }
    
    async def _analyze_technology(self, topic: str) -> Dict[str, Any]:
        """Analyze technology trends and developments"""
        return {
            'technology_overview': f"The {topic} sector is characterized by rapid technological advancement and innovation.",
            'key_technologies': [
                f"Advanced {topic} platforms",
                "Machine learning and AI integration",
                "Cloud-based solutions",
                "Mobile-first approaches",
                "API-driven architectures"
            ],
            'innovation_trends': [
                "Automation and efficiency improvements",
                "User experience optimization",
                "Data analytics and insights",
                "Security and compliance features",
                "Integration capabilities"
            ],
            'technology_readiness': {
                'mature_technologies': ["Cloud computing", "Mobile platforms", "Web APIs"],
                'emerging_technologies': [f"{topic} automation", "AI-powered analytics", "Blockchain integration"],
                'experimental_technologies': ["Quantum computing applications", "AR/VR interfaces", "IoT integration"]
            },
            'development_timeline': {
                '2024-2025': "Platform consolidation and optimization",
                '2025-2026': "AI and automation integration",
                '2026-2027': "Advanced analytics and insights",
                '2027+': "Next-generation user experiences"
            }
        }
    
    async def _analyze_competitive_landscape(self, topic: str, companies: List[Dict]) -> Dict[str, Any]:
        """Analyze competitive landscape"""
        # Create competitive segments
        segments = {}
        for company in companies:
            industry = company.get('industry', 'General')
            if industry not in segments:
                segments[industry] = []
            segments[industry].append(company)
        
        # Identify market leaders
        market_leaders = sorted(companies, 
                              key=lambda x: (self._parse_funding(x.get('funding', '0')), 
                                           self._parse_employees(x.get('employees', '0'))), 
                              reverse=True)[:5]
        
        return {
            'market_structure': {
                'total_competitors': len(companies),
                'market_segments': len(segments),
                'market_concentration': 'Fragmented' if len(companies) > 50 else 'Concentrated'
            },
            'competitive_segments': segments,
            'market_leaders': market_leaders,
            'competitive_dynamics': {
                'intensity': 'High' if len(companies) > 20 else 'Medium',
                'barriers_to_entry': ['High capital requirements', 'Technology complexity', 'Market saturation'],
                'competitive_advantages': ['Technology innovation', 'Market presence', 'Customer relationships', 'Brand recognition']
            },
            'market_positioning': {
                'leaders': market_leaders[:2],
                'challengers': market_leaders[2:5],
                'followers': companies[5:15] if len(companies) > 15 else companies[5:],
                'niche_players': companies[15:] if len(companies) > 15 else []
            }
        }
    
    async def _analyze_trends(self, topic: str) -> Dict[str, Any]:
        """Analyze market and technology trends"""
        return {
            'market_trends': {
                'current_trends': [
                    f"Growing adoption of {topic} solutions",
                    "Shift towards cloud-based platforms",
                    "Increased focus on user experience",
                    "Integration with emerging technologies"
                ],
                'future_trends': [
                    f"AI-powered {topic} solutions",
                    "Automation and workflow optimization",
                    "Enhanced data analytics capabilities",
                    "Cross-platform integration"
                ]
            },
            'technology_trends': {
                'hot_technologies': ["Artificial Intelligence", "Machine Learning", "Cloud Computing", "Mobile First"],
                'declining_technologies': ["Legacy systems", "On-premise solutions", "Manual processes"],
                'emerging_technologies': ["Quantum computing", "Edge computing", "5G integration"]
            },
            'business_model_trends': {
                'dominant_models': ["SaaS", "Platform", "Marketplace", "Freemium"],
                'emerging_models': ["Usage-based pricing", "Outcome-based pricing", "API monetization"]
            },
            'investment_trends': {
                'funding_focus': ["Early-stage startups", "Growth-stage scaling", "Market expansion"],
                'investor_types': ["VCs", "Corporate investors", "Government funds", "Angel investors"]
            }
        }
    
    async def _analyze_financials(self, topic: str, companies: List[Dict]) -> Dict[str, Any]:
        """Analyze financial metrics and trends"""
        # Handle empty companies list to avoid division by zero
        if not companies:
            logger.warning(f"No companies found for financial analysis of '{topic}'")
            return {
                'funding_overview': {
                    'total_funding': '$0B',
                    'average_funding': '$0M',
                    'funded_companies': 0,
                    'funding_penetration': '0%',
                    'note': 'No companies found matching the search criteria'
                },
                'funding_by_stage': {},
                'valuation_trends': {
                    'unicorns': 0,
                    'high_value': 0,
                    'growth_stage': 0
                },
                'financial_health_indicators': {
                    'funding_runway': 'N/A - No data',
                    'revenue_growth': 'N/A - No data',
                    'market_efficiency': 'Insufficient data',
                    'exit_activity': 'No data available'
                }
            }
        
        # Calculate financial metrics
        total_funding = sum([self._parse_funding(c.get('funding', '0')) for c in companies])
        funded_companies = [c for c in companies if c.get('funding') and self._parse_funding(c.get('funding', '0')) > 0]
        
        funding_by_stage = {}
        for company in companies:
            stage = company.get('stage', 'Unknown')
            funding = self._parse_funding(company.get('funding', '0'))
            if stage not in funding_by_stage:
                funding_by_stage[stage] = []
            funding_by_stage[stage].append(funding)
        
        # Safely calculate funding penetration
        funding_penetration = f"{len(funded_companies)/len(companies)*100:.1f}%" if companies else '0%'
        
        return {
            'funding_overview': {
                'total_funding': f"${total_funding/1e9:.1f}B",
                'average_funding': f"${total_funding/len(funded_companies)/1e6:.1f}M" if funded_companies else "$0M",
                'funded_companies': len(funded_companies),
                'funding_penetration': funding_penetration
            },
            'funding_by_stage': {stage: f"${np.mean(amounts)/1e6:.1f}M" for stage, amounts in funding_by_stage.items() if amounts},
            'valuation_trends': {
                'unicorns': len([c for c in companies if self._parse_funding(c.get('funding', '0')) > 1e9]),
                'high_value': len([c for c in companies if self._parse_funding(c.get('funding', '0')) > 100e6]),
                'growth_stage': len([c for c in companies if c.get('stage') in ['Series B', 'Series C', 'Series D']])
            },
            'financial_health_indicators': {
                'funding_runway': "12-18 months average",
                'revenue_growth': "20-40% YoY estimated",
                'market_efficiency': "Improving capital allocation",
                'exit_activity': "Moderate M&A and IPO activity"
            }
        }
    
    async def _assess_risks(self, topic: str, companies: List[Dict]) -> Dict[str, Any]:
        """Assess market and investment risks"""
        return {
            'market_risks': {
                'high_risks': [
                    "Market saturation in key segments",
                    "Regulatory changes and compliance costs",
                    "Technology disruption threats",
                    "Economic downturn impact"
                ],
                'medium_risks': [
                    "Competitive pressure intensification",
                    "Talent acquisition challenges",
                    "Funding market volatility",
                    "Customer acquisition costs"
                ],
                'low_risks': [
                    "Technology obsolescence (short-term)",
                    "Geographic expansion challenges",
                    "Partnership dependencies"
                ]
            },
            'financial_risks': {
                'funding_risks': f"{len([c for c in companies if not c.get('funding')])} companies unfunded",
                'burn_rate_concerns': "High for early-stage companies",
                'revenue_sustainability': "Variable across market segments",
                'exit_challenges': "Limited exit opportunities in current market"
            },
            'operational_risks': {
                'technology_risks': ["Platform scalability", "Security vulnerabilities", "Integration complexity"],
                'market_risks': ["Customer concentration", "Market timing", "Competition intensity"],
                'execution_risks': ["Team capabilities", "Product-market fit", "Go-to-market strategy"]
            },
            'risk_mitigation_strategies': [
                "Diversified technology portfolio",
                "Strong market positioning",
                "Financial prudence and runway management",
                "Strategic partnerships and alliances"
            ]
        }
    
    async def _identify_opportunities(self, topic: str, companies: List[Dict]) -> Dict[str, Any]:
        """Identify market opportunities"""
        return {
            'market_opportunities': {
                'underserved_segments': [
                    "Small and medium enterprises",
                    "Emerging market regions",
                    "Vertical-specific solutions",
                    "Integration and automation services"
                ],
                'technology_opportunities': [
                    f"AI-enhanced {topic} platforms",
                    "Mobile-first solutions",
                    "API and integration services",
                    "Analytics and intelligence tools"
                ],
                'business_model_opportunities': [
                    "Subscription and recurring revenue models",
                    "Platform and marketplace approaches",
                    "Outcome-based pricing models",
                    "Freemium to premium conversion"
                ]
            },
            'investment_opportunities': {
                'early_stage': f"Seed and Series A companies in {topic}",
                'growth_stage': "Scaling companies with proven traction",
                'consolidation': "Roll-up opportunities in fragmented markets",
                'international': "Geographic expansion opportunities"
            },
            'strategic_opportunities': {
                'partnerships': "Technology and distribution partnerships",
                'acquisitions': "Talent and technology acquisitions",
                'market_expansion': "New geographic and vertical markets",
                'product_development': "Next-generation product opportunities"
            }
        }
    
    async def _generate_recommendations(self, topic: str, analysis: Dict) -> Dict[str, Any]:
        """Generate strategic recommendations"""
        return {
            'strategic_recommendations': [
                f"Focus on AI and automation integration in {topic} solutions",
                "Pursue strategic partnerships with established players",
                "Invest in customer success and retention programs",
                "Develop vertical-specific solutions for underserved markets"
            ],
            'investment_recommendations': [
                "Prioritize companies with strong product-market fit",
                "Look for scalable business models and recurring revenue",
                "Consider geographic diversification opportunities",
                "Evaluate acquisition targets for strategic value"
            ],
            'operational_recommendations': [
                "Implement agile development and deployment practices",
                "Build strong data analytics and insights capabilities",
                "Focus on user experience and customer satisfaction",
                "Develop robust security and compliance frameworks"
            ],
            'market_entry_recommendations': [
                f"Enter {topic} market through acquisition or partnership",
                "Start with niche segments and expand gradually",
                "Leverage existing technology assets and capabilities",
                "Build strong go-to-market and sales capabilities"
            ]
        }
    
    async def _generate_charts_for_topic(self, topic: str, analysis_data: Dict[str, Any]) -> List[str]:
        """Generate comprehensive charts and visualizations"""
        chart_paths = []
        
        try:
            # 1. Market Distribution Pie Chart
            if 'market_analysis' in analysis_data and 'industry_distribution' in analysis_data['market_analysis']:
                pie_chart_path = await self._create_industry_distribution_chart(
                    analysis_data['market_analysis']['industry_distribution'], topic)
                chart_paths.append(pie_chart_path)
            
            # 2. Geographic Distribution Bar Chart
            if 'market_analysis' in analysis_data and 'geographic_distribution' in analysis_data['market_analysis']:
                geo_chart_path = await self._create_geographic_distribution_chart(
                    analysis_data['market_analysis']['geographic_distribution'], topic)
                chart_paths.append(geo_chart_path)
            
            # 3. Funding Analysis Chart
            if 'financial_analysis' in analysis_data and 'companies' in analysis_data:
                funding_chart_path = await self._create_funding_analysis_chart(
                    analysis_data['companies'], topic)
                chart_paths.append(funding_chart_path)
            
            # 4. Company Stage Distribution
            if 'market_analysis' in analysis_data and 'maturity_distribution' in analysis_data['market_analysis']:
                stage_chart_path = await self._create_stage_distribution_chart(
                    analysis_data['market_analysis']['maturity_distribution'], topic)
                chart_paths.append(stage_chart_path)
            
            # 5. Timeline and Trends Chart
            if 'market_analysis' in analysis_data and 'temporal_distribution' in analysis_data['market_analysis']:
                timeline_chart_path = await self._create_timeline_chart(
                    analysis_data['market_analysis']['temporal_distribution'], topic)
                chart_paths.append(timeline_chart_path)
            
            # 6. Competitive Landscape Bubble Chart
            if 'companies' in analysis_data:
                bubble_chart_path = await self._create_competitive_bubble_chart(
                    analysis_data['companies'], topic)
                chart_paths.append(bubble_chart_path)
            
        except Exception as e:
            logger.error(f"Chart generation failed: {e}")
        
        return chart_paths
    
    async def _create_industry_distribution_chart(self, industry_data: Dict[str, int], topic: str) -> str:
        """Create industry distribution pie chart"""
        try:
            fig, ax = plt.subplots(figsize=(10, 8))
            
            # Prepare data
            labels = list(industry_data.keys())[:8]  # Top 8 industries
            sizes = list(industry_data.values())[:8]
            colors = plt.cm.Set3(np.linspace(0, 1, len(labels)))
            
            # Create pie chart
            wedges, texts, autotexts = ax.pie(sizes, labels=labels, autopct='%1.1f%%', 
                                             colors=colors, startangle=90)
            
            # Customize appearance
            plt.setp(autotexts, size=8, weight="bold")
            plt.setp(texts, size=9)
            
            ax.set_title(f'{topic.title()} - Industry Distribution', fontsize=16, fontweight='bold', pad=20)
            
            # Save chart
            chart_path = os.path.join(self.charts_dir, f"{topic}_industry_distribution.png")
            plt.savefig(chart_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            return chart_path
            
        except Exception as e:
            logger.error(f"Industry distribution chart creation failed: {e}")
            return ""
    
    async def _create_geographic_distribution_chart(self, geo_data: Dict[str, int], topic: str) -> str:
        """Create geographic distribution bar chart"""
        try:
            # Prepare data - top 10 locations
            sorted_data = sorted(geo_data.items(), key=lambda x: x[1], reverse=True)[:10]
            locations = [item[0] for item in sorted_data]
            counts = [item[1] for item in sorted_data]
            
            fig, ax = plt.subplots(figsize=(12, 8))
            
            # Create horizontal bar chart
            bars = ax.barh(locations, counts, color=plt.cm.viridis(np.linspace(0, 1, len(locations))))
            
            # Customize appearance
            ax.set_xlabel('Number of Companies', fontsize=12, fontweight='bold')
            ax.set_title(f'{topic.title()} - Geographic Distribution', fontsize=16, fontweight='bold', pad=20)
            ax.grid(axis='x', alpha=0.3)
            
            # Add value labels on bars
            for bar in bars:
                width = bar.get_width()
                ax.text(width, bar.get_y() + bar.get_height()/2, 
                       f'{int(width)}', ha='left', va='center', fontweight='bold')
            
            plt.tight_layout()
            
            # Save chart
            chart_path = os.path.join(self.charts_dir, f"{topic}_geographic_distribution.png")
            plt.savefig(chart_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            return chart_path
            
        except Exception as e:
            logger.error(f"Geographic distribution chart creation failed: {e}")
            return ""
    
    async def _create_funding_analysis_chart(self, companies: List[Dict], topic: str) -> str:
        """Create funding analysis chart"""
        try:
            # Prepare funding data
            funding_data = []
            for company in companies:
                if company.get('funding'):
                    funding_amount = self._parse_funding(company.get('funding', '0'))
                    if funding_amount > 0:
                        funding_data.append({
                            'name': company.get('name', 'Unknown'),
                            'funding': funding_amount / 1e6,  # Convert to millions
                            'stage': company.get('stage', 'Unknown')
                        })
            
            if not funding_data:
                return ""
            
            # Sort by funding amount and take top 15
            funding_data = sorted(funding_data, key=lambda x: x['funding'], reverse=True)[:15]
            
            fig, ax = plt.subplots(figsize=(14, 8))
            
            # Create bar chart
            names = [d['name'][:20] + '...' if len(d['name']) > 20 else d['name'] for d in funding_data]
            amounts = [d['funding'] for d in funding_data]
            stages = [d['stage'] for d in funding_data]
            
            # Color by stage
            stage_colors = {'Seed': 'lightblue', 'Series A': 'blue', 'Series B': 'orange', 
                           'Series C': 'red', 'Series D': 'purple', 'Public': 'green', 'Unknown': 'gray'}
            colors = [stage_colors.get(stage, 'gray') for stage in stages]
            
            bars = ax.bar(range(len(names)), amounts, color=colors)
            
            # Customize appearance
            ax.set_xlabel('Companies', fontsize=12, fontweight='bold')
            ax.set_ylabel('Funding ($ Millions)', fontsize=12, fontweight='bold')
            ax.set_title(f'{topic.title()} - Top Companies by Funding', fontsize=16, fontweight='bold', pad=20)
            ax.set_xticks(range(len(names)))
            ax.set_xticklabels(names, rotation=45, ha='right')
            ax.grid(axis='y', alpha=0.3)
            
            # Add value labels on bars
            for bar in bars:
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width()/2, height,
                       f'${height:.1f}M', ha='center', va='bottom', fontweight='bold', fontsize=8)
            
            plt.tight_layout()
            
            # Save chart
            chart_path = os.path.join(self.charts_dir, f"{topic}_funding_analysis.png")
            plt.savefig(chart_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            return chart_path
            
        except Exception as e:
            logger.error(f"Funding analysis chart creation failed: {e}")
            return ""
    
    async def _create_stage_distribution_chart(self, stage_data: Dict[str, int], topic: str) -> str:
        """Create company stage distribution donut chart"""
        try:
            fig, ax = plt.subplots(figsize=(10, 8))
            
            # Prepare data
            labels = list(stage_data.keys())
            sizes = list(stage_data.values())
            colors = plt.cm.Pastel1(np.linspace(0, 1, len(labels)))
            
            # Create donut chart
            wedges, texts, autotexts = ax.pie(sizes, labels=labels, autopct='%1.1f%%',
                                             colors=colors, startangle=90, pctdistance=0.85)
            
            # Create donut effect
            centre_circle = plt.Circle((0,0), 0.70, fc='white')
            fig.gca().add_artist(centre_circle)
            
            # Customize appearance
            plt.setp(autotexts, size=10, weight="bold")
            plt.setp(texts, size=10)
            
            ax.set_title(f'{topic.title()} - Company Stage Distribution', fontsize=16, fontweight='bold', pad=20)
            
            # Save chart
            chart_path = os.path.join(self.charts_dir, f"{topic}_stage_distribution.png")
            plt.savefig(chart_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            return chart_path
            
        except Exception as e:
            logger.error(f"Stage distribution chart creation failed: {e}")
            return ""
    
    async def _create_timeline_chart(self, temporal_data: Dict[str, int], topic: str) -> str:
        """Create timeline/founding trends chart"""
        try:
            fig, ax = plt.subplots(figsize=(12, 6))
            
            # Prepare data
            years = sorted(temporal_data.keys())
            counts = [temporal_data[year] for year in years]
            
            # Create line chart with area fill
            ax.plot(years, counts, marker='o', linewidth=3, markersize=8, color='#2E86C1')
            ax.fill_between(years, counts, alpha=0.3, color='#2E86C1')
            
            # Customize appearance
            ax.set_xlabel('Time Period', fontsize=12, fontweight='bold')
            ax.set_ylabel('Number of Companies Founded', fontsize=12, fontweight='bold')
            ax.set_title(f'{topic.title()} - Company Founding Trends', fontsize=16, fontweight='bold', pad=20)
            ax.grid(True, alpha=0.3)
            
            # Add value labels on points
            for i, (year, count) in enumerate(zip(years, counts)):
                ax.annotate(str(count), (year, count), textcoords="offset points", 
                           xytext=(0,10), ha='center', fontweight='bold')
            
            plt.tight_layout()
            
            # Save chart
            chart_path = os.path.join(self.charts_dir, f"{topic}_timeline_trends.png")
            plt.savefig(chart_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            return chart_path
            
        except Exception as e:
            logger.error(f"Timeline chart creation failed: {e}")
            return ""
    
    async def _create_competitive_bubble_chart(self, companies: List[Dict], topic: str) -> str:
        """Create competitive landscape bubble chart"""
        try:
            # Prepare data for bubble chart
            bubble_data = []
            for company in companies[:20]:  # Top 20 companies
                funding = self._parse_funding(company.get('funding', '0')) / 1e6  # Millions
                employees = self._parse_employees(company.get('employees', '0'))
                age = 2024 - company.get('founded_year', 2020)
                
                if funding > 0 or employees > 0:
                    bubble_data.append({
                        'name': company.get('name', 'Unknown'),
                        'funding': funding,
                        'employees': employees,
                        'age': age,
                        'stage': company.get('stage', 'Unknown')
                    })
            
            if not bubble_data:
                return ""
            
            fig, ax = plt.subplots(figsize=(14, 10))
            
            # Create bubble chart
            x = [d['funding'] for d in bubble_data]
            y = [d['employees'] for d in bubble_data]
            sizes = [(d['age'] + 1) * 50 for d in bubble_data]  # Size based on company age
            
            # Color by stage
            stage_colors = {'Seed': 'lightblue', 'Series A': 'blue', 'Series B': 'orange', 
                           'Series C': 'red', 'Series D': 'purple', 'Public': 'green', 'Unknown': 'gray'}
            colors = [stage_colors.get(d['stage'], 'gray') for d in bubble_data]
            
            scatter = ax.scatter(x, y, s=sizes, c=colors, alpha=0.6, edgecolors='black', linewidth=1)
            
            # Add company labels
            for d in bubble_data:
                if d['funding'] > 0 or d['employees'] > 0:  # Only label significant companies
                    ax.annotate(d['name'][:10], (d['funding'], d['employees']), 
                               fontsize=8, ha='center', va='center')
            
            # Customize appearance
            ax.set_xlabel('Funding ($ Millions)', fontsize=12, fontweight='bold')
            ax.set_ylabel('Number of Employees', fontsize=12, fontweight='bold')
            ax.set_title(f'{topic.title()} - Competitive Landscape\n(Bubble size = Company age)', 
                        fontsize=16, fontweight='bold', pad=20)
            ax.grid(True, alpha=0.3)
            
            # Add legend for stages
            unique_stages = list(set(d['stage'] for d in bubble_data))
            legend_elements = [plt.scatter([], [], c=stage_colors.get(stage, 'gray'), 
                                         s=100, label=stage) for stage in unique_stages]
            ax.legend(handles=legend_elements, title='Funding Stage', loc='upper right')
            
            plt.tight_layout()
            
            # Save chart
            chart_path = os.path.join(self.charts_dir, f"{topic}_competitive_landscape.png")
            plt.savefig(chart_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            return chart_path
            
        except Exception as e:
            logger.error(f"Competitive bubble chart creation failed: {e}")
            return ""
    
    def _parse_funding(self, funding_str: str) -> float:
        """Parse funding string to numeric value"""
        if not funding_str or funding_str == 'N/A':
            return 0.0
        
        # Remove currency symbols and convert to lowercase
        funding_str = re.sub(r'[^\d.kmb]+', '', funding_str.lower())
        
        try:
            if 'b' in funding_str:
                return float(funding_str.replace('b', '')) * 1e9
            elif 'm' in funding_str:
                return float(funding_str.replace('m', '')) * 1e6
            elif 'k' in funding_str:
                return float(funding_str.replace('k', '')) * 1e3
            else:
                return float(funding_str)
        except:
            return 0.0
    
    def _parse_employees(self, employees_str: str) -> int:
        """Parse employees string to numeric value"""
        if not employees_str or employees_str == 'N/A':
            return 0
        
        # Extract numbers and handle ranges
        numbers = re.findall(r'\d+', employees_str)
        if numbers:
            if len(numbers) > 1:  # Range like "100-500"
                return (int(numbers[0]) + int(numbers[1])) // 2
            else:
                return int(numbers[0])
        return 0
    
    async def _generate_ai_html_content(self, topic: str, analysis_data: Dict[str, Any], 
                                        report_type: str) -> str:
        """Generate beautiful HTML content using AI"""
        try:
            # Prepare context for AI
            executive_summary = analysis_data.get('executive_summary', {})
            market_analysis = analysis_data.get('market_analysis', {})
            companies = analysis_data.get('companies', [])[:10]
            company_list = ', '.join([c.get('name', 'Unknown') for c in companies])
            
            # AI prompt to generate HTML report content
            html_prompt = f"""Generate a professional, beautifully formatted HTML report (2-4 pages when printed on A4) for: {topic}

REPORT TYPE: {report_type}

DATA AVAILABLE:
- Companies: {len(companies)} ({company_list[:200]}...)
- Market Size: {executive_summary.get('market_size_estimate', 'Analyzing...')}
- Growth Rate: {executive_summary.get('growth_rate', 'Analyzing...')}

REQUIREMENTS:
1. Create well-structured HTML with semantic tags
2. Include inline CSS for beautiful A4 printing
3. Use professional colors (#667eea for primary, #2c3e50 for text)
4. Sections: Executive Summary, Market Analysis, Key Companies, Trends & Opportunities, Conclusion
5. Include relevant metrics, numbers, and insights
6. Use tables, lists, and formatting for readability
7. Keep content to 2-4 pages when printed on A4
8. Make it visually appealing with gradients, boxes, and proper spacing
9. Use REAL data and insights based on {topic} industry

Return ONLY the HTML content (no explanations). Start with <html> and end with </html>."""

            # Get AI-generated HTML
            html_content = await self.crew_manager.handle_conversation(html_prompt, "html_gen")
            
            # Ensure html_content is a string
            if not isinstance(html_content, str):
                logger.warning(f"AI returned non-string response (type: {type(html_content)}), using fallback")
                return self._create_fallback_html(topic, analysis_data, report_type)
            
            # Extract HTML if AI wrapped it in markdown code blocks
            if "```html" in html_content:
                html_content = html_content.split("```html")[1].split("```")[0].strip()
            elif "```" in html_content:
                html_content = html_content.split("```")[1].split("```")[0].strip()
            
            # Fallback if AI didn't generate proper HTML
            if not html_content.startswith("<html") and not html_content.startswith("<!DOCTYPE"):
                logger.warning("AI response doesn't start with HTML tags, using fallback")
                html_content = self._create_fallback_html(topic, analysis_data, report_type)
            
            return html_content
            
        except Exception as e:
            logger.error(f"AI HTML generation failed: {e}, using fallback")
            return self._create_fallback_html(topic, analysis_data, report_type)
    
    def _create_fallback_html(self, topic: str, analysis_data: Dict[str, Any], report_type: str) -> str:
        """Create concise fallback HTML (2-3 pages max)"""
        executive_summary = analysis_data.get('executive_summary', {})
        companies = analysis_data.get('companies', [])[:5]  # Reduced to 5 companies
        market_analysis = analysis_data.get('market_analysis', {})
        
        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{topic} - {report_type} Report</title>
    <style>
        @page {{
            size: A4;
            margin: 15mm;
        }}
        
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            background: white;
        }}
        
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 30px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 30px;
        }}
        
        .header h1 {{
            font-size: 32px;
            margin-bottom: 10px;
            font-weight: 700;
        }}
        
        .header p {{
            font-size: 16px;
            opacity: 0.95;
        }}
        
        .meta-info {{
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
        }}
        
        .meta-info table {{
            width: 100%;
            border-collapse: collapse;
        }}
        
        .meta-info td {{
            padding: 8px;
            border-bottom: 1px solid #dee2e6;
        }}
        
        .meta-info td:first-child {{
            font-weight: 600;
            width: 150px;
            color: #667eea;
        }}
        
        .section {{
            margin-bottom: 30px;
            page-break-inside: avoid;
        }}
        
        h2 {{
            color: #667eea;
            font-size: 24px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }}
        
        h3 {{
            color: #2c3e50;
            font-size: 18px;
            margin: 20px 0 10px;
        }}
        
        p {{
            margin-bottom: 12px;
            text-align: justify;
        }}
        
        .highlight-box {{
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }}
        
        ul {{
            margin: 15px 0;
            padding-left: 30px;
        }}
        
        li {{
            margin-bottom: 8px;
        }}
        
        .metric-grid {{
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }}
        
        .metric-card {{
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border-top: 4px solid #667eea;
        }}
        
        .metric-value {{
            font-size: 28px;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }}
        
        .metric-label {{
            font-size: 13px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }}
        
        table {{
            width: 100%;
            max-width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
            margin: 20px 0;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }}
        
        th {{
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }}
        
        td {{
            padding: 10px 12px;
            border-bottom: 1px solid #dee2e6;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 0;
        }}
        
        tr:nth-child(even) {{
            background: #f8f9fa;
        }}
        
        .footer {{
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #dee2e6;
            text-align: center;
            color: #6c757d;
            font-size: 12px;
        }}
        
        .page-break {{
            page-break-after: always;
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1> Nexalyze</h1>
        <p>AI-Powered Startup Research & Competitive Intelligence</p>
    </div>
    
    <div class="meta-info">
        <table>
            <tr>
                <td>Report Topic:</td>
                <td><strong>{topic}</strong></td>
            </tr>
            <tr>
                <td>Report Type:</td>
                <td><strong>{report_type.title()}</strong></td>
            </tr>
            <tr>
                <td>Generated:</td>
                <td><strong>{datetime.now().strftime('%B %d, %Y at %I:%M %p')}</strong></td>
            </tr>
            <tr>
                <td>Companies Analyzed:</td>
                <td><strong>{len(companies)}</strong></td>
            </tr>
        </table>
    </div>
    
    <div class="section">
        <h2> Executive Summary</h2>
        <p>{executive_summary.get('overview', f'Comprehensive analysis of the {topic} market reveals significant opportunities and dynamic growth patterns. The sector is characterized by innovation, substantial investment activity, and rapid market evolution.')}</p>
        
        <div class="metric-grid">
            <div class="metric-card">
                <div class="metric-value">{len(companies)}</div>
                <div class="metric-label">Companies</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">{executive_summary.get('market_size_estimate', '$500M+')}</div>
                <div class="metric-label">Market Size</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">{executive_summary.get('growth_rate', '25% CAGR')}</div>
                <div class="metric-label">Growth Rate</div>
            </div>
        </div>
        
        <h3>Key Findings</h3>
        <ul>
"""
        
        # Add key findings
        for finding in executive_summary.get('key_findings', [
            f"Strong market presence with {len(companies)} active companies across multiple sectors",
            f"Innovation-driven growth with significant R&D investments",
            f"Geographic diversification across major technology hubs",
            f"Attractive investment landscape with VC backing and strategic partnerships"
        ])[:6]:
            html += f"            <li>{finding}</li>\n"
        
        html += """        </ul>
    </div>
    
    <div class="section">
        <h2> Market Analysis</h2>
        <p>The market demonstrates robust fundamentals with strong growth indicators and sustained investor interest. Key market dynamics include:</p>
        
        <div class="highlight-box">
            <h3>Market Characteristics</h3>
            <ul>
                <li><strong>Market Maturity:</strong> Rapidly evolving with high innovation velocity</li>
                <li><strong>Competition Intensity:</strong> Moderate to high with clear market leaders and emerging challengers</li>
                <li><strong>Entry Barriers:</strong> Technology expertise, capital requirements, and market access</li>
                <li><strong>Growth Drivers:</strong> Digital transformation, AI/ML adoption, and changing customer needs</li>
            </ul>
        </div>
"""
        
        # Add top companies table
        if companies:
            html += """        
        <h3>Top Companies in the Ecosystem</h3>
        <table>
            <thead>
                <tr>
                    <th>#</th>
                    <th>Company</th>
                    <th>Industry</th>
                    <th>Location</th>
                </tr>
            </thead>
            <tbody>
"""
            for idx, company in enumerate(companies[:8], 1):
                html += f"""                <tr>
                    <td>{idx}</td>
                    <td><strong>{company.get('name', 'Unknown')}</strong></td>
                    <td>{company.get('industry', 'Technology')}</td>
                    <td>{company.get('location', 'N/A')}</td>
                </tr>
"""
            html += """            </tbody>
        </table>
"""
        
        html += """    </div>
    
    <div class="page-break"></div>
    
    <div class="section">
        <h2> Key Trends & Opportunities</h2>
        <p>The market presents several compelling opportunities for stakeholders, investors, and new entrants:</p>
        
        <h3> Emerging Trends</h3>
        <ul>
            <li><strong>AI & Machine Learning Integration:</strong> Companies are increasingly leveraging AI for competitive advantage</li>
            <li><strong>Platform Consolidation:</strong> Movement towards integrated solutions and ecosystem plays</li>
            <li><strong>Global Expansion:</strong> Companies expanding beyond initial markets into new geographies</li>
            <li><strong>Enterprise Focus:</strong> Shift from consumer to B2B and enterprise-grade solutions</li>
        </ul>
        
        <h3> Strategic Opportunities</h3>
        <div class="highlight-box">
            <ul>
                <li><strong>Market Gaps:</strong> Underserved segments and niche verticals present entry opportunities</li>
                <li><strong>Technology Innovation:</strong> Next-generation solutions can disrupt established players</li>
                <li><strong>Partnership Potential:</strong> Collaboration opportunities with complementary businesses</li>
                <li><strong>M&A Activity:</strong> Consolidation creating acquisition targets and strategic deals</li>
            </ul>
        </div>
    </div>
    
    <div class="section">
        <h2> Conclusion & Recommendations</h2>
        <p>The {topic} market represents a vibrant and growing sector with substantial opportunities for informed participants. Our analysis reveals:</p>
        
        <div class="highlight-box">
            <h3>Strategic Recommendations</h3>
            <ul>
                <li><strong>For Investors:</strong> Focus on companies with strong unit economics, proven traction, and defensible market positions</li>
                <li><strong>For Entrepreneurs:</strong> Identify underserved niches and leverage emerging technologies to create differentiated value propositions</li>
                <li><strong>For Incumbents:</strong> Consider strategic partnerships or acquisitions to accelerate growth and expand capabilities</li>
                <li><strong>For Analysts:</strong> Monitor competitive dynamics, funding patterns, and technology adoption rates as key indicators</li>
            </ul>
        </div>
        
        <p>The next 12-24 months will be critical as market leaders consolidate positions and new challengers emerge with innovative approaches. Stakeholders should remain agile and data-driven in their decision-making.</p>
    </div>
    
    <div class="footer">
        <p><strong>Nexalyze</strong> | AI-Powered Startup Research & Competitive Intelligence</p>
        <p>Generated on {datetime.now().strftime('%B %d, %Y')} | Confidential & Proprietary</p>
        <p style="margin-top: 10px; font-size: 10px;">This report is generated using AI-powered analysis of real company data, market research, and industry insights.</p>
    </div>
</body>
</html>"""
        
        return html
    
    async def _generate_enhanced_pdf_report(self, topic: str, analysis_data: Dict[str, Any], 
                                          chart_paths: List[str], report_type: str) -> str:
        """Generate enhanced PDF report from AI-generated HTML"""
        try:
            logger.info(f"Generating AI-powered HTML-to-PDF report for {topic}...")
            
            # Step 1: Generate beautiful HTML content using AI
            html_content = await self._generate_ai_html_content(topic, analysis_data, report_type)
            
            # Step 2: Save HTML file (for debugging/preview)
            safe_topic = re.sub(r'[^\w\-_.]', '_', topic)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            html_filename = f"{safe_topic}_{report_type}_report_{timestamp}.html"
            html_filepath = os.path.join(self.reports_dir, html_filename)
            
            with open(html_filepath, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            logger.info(f"HTML report saved: {html_filepath}")
            
            # Step 3: Convert HTML to PDF using weasyprint
            pdf_filename = f"{safe_topic}_{report_type}_report_{timestamp}.pdf"
            filepath = os.path.join(self.reports_dir, pdf_filename)
            
            try:
                # Try using weasyprint (best quality)
                from weasyprint import HTML, CSS
                HTML(string=html_content).write_pdf(filepath)
                logger.info(f"PDF generated using WeasyPrint: {filepath}")
            except ImportError:
                logger.warning("WeasyPrint not available, trying pdfkit...")
                try:
                    # Fallback to pdfkit
                    import pdfkit
                    pdfkit.from_string(html_content, filepath, options={
                        'page-size': 'A4',
                        'encoding': 'UTF-8',
                        'enable-local-file-access': ''
                    })
                    logger.info(f"PDF generated using pdfkit: {filepath}")
                except ImportError:
                    logger.error("pdfkit not available. Please install WeasyPrint or pdfkit for PDF generation.")
                    raise ImportError("PDF generation requires WeasyPrint or pdfkit. Please install one of them.")
            
            logger.info(f" Enhanced AI-powered PDF report generated: {filepath}")
            return filepath
            
        except Exception as e:
            logger.error(f"Enhanced PDF generation failed: {e}")
            raise
    
    async def _compile_langgraph_report_to_pdf(
        self, topic: str, report_sections: List[Dict[str, Any]], 
        content_table: Any, analysis_data: Dict[str, Any], 
        chart_paths: List[str], report_type: str
    ) -> str:
        """
        Compile LangGraph-generated report sections into a PDF report.
        """
        try:
            logger.info(f"Compiling LangGraph report sections to PDF for {topic}")
            
            # Build HTML from sections
            html_content = self._build_html_from_sections(
                topic, report_sections, content_table, analysis_data, chart_paths, report_type
            )
            
            # Save HTML file
            safe_topic = re.sub(r'[^\w\-_.]', '_', topic)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            html_filename = f"{safe_topic}_{report_type}_report_{timestamp}.html"
            html_filepath = os.path.join(self.reports_dir, html_filename)
            
            with open(html_filepath, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            logger.info(f"HTML report saved: {html_filepath}")
            
            # Convert HTML to PDF
            pdf_filename = f"{safe_topic}_{report_type}_comprehensive_report_{timestamp}.pdf"
            filepath = os.path.join(self.reports_dir, pdf_filename)
            
            try:
                from weasyprint import HTML
                HTML(string=html_content).write_pdf(filepath)
                logger.info(f"PDF generated using WeasyPrint: {filepath}")
            except ImportError:
                logger.warning("WeasyPrint not available, trying pdfkit...")
                try:
                    import pdfkit
                    pdfkit.from_string(html_content, filepath, options={
                        'page-size': 'A4',
                        'encoding': 'UTF-8',
                        'enable-local-file-access': ''
                    })
                    logger.info(f"PDF generated using pdfkit: {filepath}")
                except ImportError:
                    logger.error("pdfkit not available. Please install WeasyPrint or pdfkit for PDF generation.")
                    raise ImportError("PDF generation requires WeasyPrint or pdfkit. Please install one of them.")
            
            logger.info(f" LangGraph PDF report generated: {filepath}")
            return filepath
            
        except Exception as e:
            logger.error(f"LangGraph PDF compilation failed: {e}")
            import traceback
            traceback.print_exc()
            raise
    
    def _encode_image_to_base64(self, image_path: str) -> str:
        """Convert image file to base64 data URL for HTML embedding"""
        try:
            with open(image_path, 'rb') as image_file:
                encoded_string = base64.b64encode(image_file.read()).decode('utf-8')
                return f"data:image/png;base64,{encoded_string}"
        except Exception as e:
            logger.error(f"Failed to encode image {image_path}: {e}")
            return ""
    
    def _build_html_from_sections(
        self, topic: str, report_sections: List[Dict[str, Any]], 
        content_table: Any, analysis_data: Dict[str, Any], 
        chart_paths: List[str], report_type: str
    ) -> str:
        """Build complete HTML report from LangGraph sections"""
        companies = analysis_data.get('companies', [])
        executive_summary = analysis_data.get('executive_summary', {})
        
        # Get report title from content table
        report_title = getattr(content_table, 'title', f"{topic.title()} - {report_type.title()} Report") if content_table else f"{topic.title()} - {report_type.title()} Report"
        report_summary = getattr(content_table, 'summary', None) if content_table else None
        
        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{report_title}</title>
    <style>
        @page {{
            size: A4;
            margin: 15mm;
        }}
        
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            background: white;
        }}
        
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 30px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 30px;
        }}
        
        .header h1 {{
            font-size: 32px;
            margin-bottom: 10px;
            font-weight: 700;
        }}
        
        .header p {{
            font-size: 16px;
            opacity: 0.95;
        }}
        
        .meta-info {{
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
        }}
        
        .meta-info table {{
            width: 100%;
            border-collapse: collapse;
        }}
        
        .meta-info td {{
            padding: 8px;
            border-bottom: 1px solid #dee2e6;
        }}
        
        .meta-info td:first-child {{
            font-weight: 600;
            width: 150px;
            color: #667eea;
        }}
        
        .section {{
            margin-bottom: 30px;
            page-break-inside: avoid;
        }}
        
        h2 {{
            color: #667eea;
            font-size: 24px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }}
        
        h3 {{
            color: #2c3e50;
            font-size: 18px;
            margin: 20px 0 10px;
        }}
        
        p {{
            margin-bottom: 12px;
            text-align: justify;
        }}
        
        .highlight-box {{
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }}
        
        ul, ol {{
            margin: 15px 0;
            padding-left: 30px;
        }}
        
        li {{
            margin-bottom: 8px;
        }}
        
        table {{
            width: 100%;
            table-layout: auto;
            border-collapse: collapse;
            margin: 20px 0;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }}
        
        th {{
            background: #667eea;
            color: white;
            padding: 8px 10px;
            text-align: left;
            font-weight: 600;
            vertical-align: top;
            word-break: break-word;
        }}
        
        td {{
            padding: 8px 10px;
            border-bottom: 1px solid #dee2e6;
            vertical-align: top;
            word-break: break-word;
            hyphens: auto;
        }}
        
        tr:nth-child(even) {{
            background: #f8f9fa;
        }}
        
        .chart-container {{
            margin: 20px 0;
            text-align: center;
            max-width: 100%;
            overflow: hidden;
        }}
        
        .chart-container img {{
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: block;
            margin: 0 auto;
        }}
        
        .footer {{
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #dee2e6;
            text-align: center;
            color: #6c757d;
            font-size: 12px;
        }}
        
        .page-break {{
            page-break-after: always;
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1> Nexalyze</h1>
        <p>AI-Powered Startup Research & Competitive Intelligence</p>
    </div>
    
    <div class="meta-info">
        <table>
            <tr>
                <td>Report Title:</td>
                <td><strong>{report_title}</strong></td>
            </tr>
            <tr>
                <td>Report Type:</td>
                <td><strong>{report_type.title()}</strong></td>
            </tr>
            <tr>
                <td>Generated:</td>
                <td><strong>{datetime.now().strftime('%B %d, %Y at %I:%M %p')}</strong></td>
            </tr>
            <tr>
                <td>Companies Analyzed:</td>
                <td><strong>{len(companies)}</strong></td>
            </tr>
            <tr>
                <td>Sections:</td>
                <td><strong>{len(report_sections)}</strong></td>
            </tr>
        </table>
    </div>
"""
        
        # Add summary if available
        if report_summary:
            html += f"""
    <div class="section">
        <div class="highlight-box">
            <h3>Report Overview</h3>
            <p>{report_summary}</p>
        </div>
    </div>
"""
        
        # Add report sections
        for idx, section in enumerate(report_sections, 1):
            html += f"""
    <div class="section">
        {section.get('content', '')}
    </div>
"""
            
            # Add page break after every 2-3 sections (except last)
            if idx % 3 == 0 and idx < len(report_sections):
                html += """    <div class="page-break"></div>
"""
        
        # Add charts if available
        if chart_paths:
            html += """
    <div class="section">
        <h2> Visualizations & Charts</h2>
"""
            for chart_path in chart_paths:
                if os.path.exists(chart_path):
                    # Encode chart as base64 PNG for direct HTML embedding
                    chart_filename = os.path.basename(chart_path)
                    chart_data_url = self._encode_image_to_base64(chart_path)
                    if chart_data_url:
                        html += f"""
        <div class="chart-container">
            <img src="{chart_data_url}" alt="Chart: {chart_filename}" />
        </div>
"""
            html += """    </div>
"""
        
        # Add footer
        html += f"""
    <div class="footer">
        <p><strong>Nexalyze</strong> | AI-Powered Startup Research & Competitive Intelligence</p>
        <p>Generated on {datetime.now().strftime('%B %d, %Y')} | Confidential & Proprietary</p>
        <p style="margin-top: 10px; font-size: 10px;">This report was generated using LangGraph AI agents with data-driven analysis of real company data, market research, and industry insights.</p>
    </div>
</body>
</html>"""
        
        return html
    
    async def _compile_langgraph_report_to_docx(
        self, topic: str, report_sections: List[Dict[str, Any]], 
        content_table: Any, analysis_data: Dict[str, Any], 
        chart_paths: List[str], report_type: str
    ) -> str:
        """Compile LangGraph-generated report sections into a DOCX report."""
        if not DOCX_AVAILABLE:
            raise ValueError("python-docx library not available")
        
        try:
            logger.info(f"Compiling LangGraph report sections to DOCX for {topic}")
            
            # Create filename
            safe_topic = re.sub(r'[^\w\-_.]', '_', topic)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{safe_topic}_{report_type}_comprehensive_report_{timestamp}.docx"
            filepath = os.path.join(self.reports_dir, filename)
            
            # Create document
            doc = Document()
            
            # Add title
            title = doc.add_heading('Nexalyze', 0)
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            report_title = getattr(content_table, 'title', f"{topic.title()} - {report_type.title()} Report") if content_table else f"{topic.title()} - {report_type.title()} Report"
            subtitle = doc.add_heading(report_title, level=1)
            subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            # Add metadata
            doc.add_paragraph(f"Generated: {datetime.now().strftime('%B %d, %Y at %I:%M %p')}")
            doc.add_paragraph(f"Report Type: {report_type.title()}")
            doc.add_paragraph(f"Companies Analyzed: {len(analysis_data.get('companies', []))}")
            doc.add_paragraph(f"Sections: {len(report_sections)}")
            
            # Add summary if available
            if content_table and hasattr(content_table, 'summary') and content_table.summary:
                doc.add_heading('Report Overview', level=2)
                doc.add_paragraph(content_table.summary)
            
            # Add sections
            for section in report_sections:
                # Convert HTML to DOCX (simplified - just extract text)
                heading = section.get('heading', 'Section')
                content = section.get('content', '')
                
                # Add heading
                doc.add_heading(heading, level=2)
                
                # Extract text from HTML (simple approach)
                from bs4 import BeautifulSoup
                soup = BeautifulSoup(content, 'html.parser')
                text_content = soup.get_text(separator='\n', strip=True)
                
                # Add paragraphs
                for para in text_content.split('\n'):
                    if para.strip():
                        doc.add_paragraph(para.strip())
            
            # Add charts
            if chart_paths:
                doc.add_heading('Visualizations & Charts', level=2)
                for chart_path in chart_paths:
                    if os.path.exists(chart_path):
                        try:
                            doc.add_picture(chart_path, width=Inches(6))
                        except Exception as e:
                            logger.warning(f"Could not add chart {chart_path}: {e}")
            
            # Save document
            doc.save(filepath)
            
            logger.info(f" LangGraph DOCX report generated: {filepath}")
            return filepath
            
        except Exception as e:
            logger.error(f"LangGraph DOCX compilation failed: {e}")
            import traceback
            traceback.print_exc()
            raise
    
    async def _generate_enhanced_docx_report(self, topic: str, analysis_data: Dict[str, Any], 
                                           chart_paths: List[str], report_type: str) -> str:
        """Generate enhanced DOCX report with charts and comprehensive analysis"""
        if not DOCX_AVAILABLE:
            raise ValueError("python-docx library not available")
        
        # Similar implementation to PDF but for DOCX format
        # This would follow the same structure but use python-docx instead of ReportLab
        # Implementation would be similar to the existing DOCX methods but enhanced
        
        try:
            # Create filename
            safe_topic = re.sub(r'[^\w\-_.]', '_', topic)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{safe_topic}_{report_type}_report_{timestamp}.docx"
            filepath = os.path.join(self.reports_dir, filename)
            
            # Create document (implementation details similar to existing DOCX methods)
            doc = Document()
            
            # Add title
            title = doc.add_heading('Nexalyze', 0)
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            subtitle = doc.add_heading(f'Comprehensive Analysis Report: {topic.title()}', level=1)
            subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            # Add content sections (similar to PDF structure)
            # ... (implementation continues)
            
            doc.save(filepath)
            
            logger.info(f"Enhanced DOCX report generated successfully: {filepath}")
            return filepath
            
        except Exception as e:
            logger.error(f"Enhanced DOCX generation failed: {e}")
            raise
    
    def get_report_file(self, report_path: str) -> bytes:
        """Get report file as bytes for download"""
        try:
            with open(report_path, 'rb') as f:
                return f.read()
        except Exception as e:
            logger.error(f"Failed to read report file {report_path}: {e}")
            raise
    
    def cleanup_old_reports(self, days_old: int = 7):
        """Clean up reports older than specified days"""
        try:
            import time
            current_time = time.time()
            cutoff_time = current_time - (days_old * 24 * 60 * 60)
            
            cleaned_count = 0
            for directory in [self.reports_dir, self.charts_dir]:
                if os.path.exists(directory):
                    for filename in os.listdir(directory):
                        filepath = os.path.join(directory, filename)
                        if os.path.isfile(filepath):
                            file_time = os.path.getmtime(filepath)
                            if file_time < cutoff_time:
                                os.remove(filepath)
                                cleaned_count += 1
            
            logger.info(f"Cleaned up {cleaned_count} old files")
            return cleaned_count
            
        except Exception as e:
            logger.error(f"Failed to cleanup old files: {e}")
            return 0


# Backwards compatibility alias
EnhancedReportService = ReportService